<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>机器学习 on Davidham的博客</title><link>https://davidham3.github.io/blog/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</link><description>Recent content in 机器学习 on Davidham的博客</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 11 Sep 2018 14:12:30 +0000</lastBuildDate><atom:link href="https://davidham3.github.io/blog/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml"/><item><title>神经网络基础</title><link>https://davidham3.github.io/blog/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link><pubDate>Tue, 11 Sep 2018 14:12:30 +0000</pubDate><guid>https://davidham3.github.io/blog/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid><description>&lt;p>最近给本科生当机器学习课程的助教，给他们出的作业题需要看这些图，懒得放本地了，直接放博客里。发现jupyter导出markdown好方便，放到博客里面正好，改都不用改。&lt;/p>
&lt;p>原来就想过一个问题，为什么我写出来的神经网络不收敛，loss会像火箭一样直接飞了。后来看了一些教程，发现有人在做梯度下降的时候，把梯度除以了梯度的二范数，我尝试之后发现还真好使了，在实验的时候发现是因为没有对数据集进行归一化，如果所有的数据都是很大的数，那么在反向传播的时候，计算出来的梯度的数量级会很大，这就导致更新得到的参数的数量级也很大，预测出的偏差就更大了，然后循环往复，如果给梯度除以一个梯度的二范数，其实就相当于把梯度的数量级降了，这样就可以训练了。但实际上还是将原始数据归一化比较好，对原始数据归一化还能让梯度下降的方向更多。如果数据都是正数，那下降方向会少很多，下降的时候会出现zig-zag现象。&lt;/p>
&lt;h1 id="第二题神经网络线性回归">第二题：神经网络：线性回归
&lt;/h1>&lt;p>实验内容：&lt;/p>
&lt;ol>
&lt;li>学会梯度下降的基本思想&lt;/li>
&lt;li>学会使用梯度下降求解线性回归&lt;/li>
&lt;li>了解归一化处理的作用&lt;/li>
&lt;/ol>
&lt;h2 id="线性回归">线性回归
&lt;/h2>&lt;p>&lt;img src="https://davidham3.github.io/blog/images/logistic-regression/Fig0.png"
loading="lazy"
alt="Figure0"
>&lt;/p>
&lt;p>我们来完成最简单的线性回归，上图是一个最简单的神经网络，一个输入层，一个输出层，没有激活函数。&lt;br>
我们记输入为$X \in \mathbb{R}^{n \times m}$，输出为$Z \in \mathbb{R}^{n}$。输入包含了$n$个样本，$m$个特征，输出是对这$n$个样本的预测值。&lt;br>
输入层到输出层的权重和偏置，我们记为$W \in \mathbb{R}^{m}$和$b \in \mathbb{R}$。&lt;br>
输出层没有激活函数，所以上面的神经网络的前向传播过程写为：&lt;/p>
$$
Z = XW + b
$$&lt;p>我们使用均方误差作为模型的损失函数&lt;/p>
$$
\mathrm{loss}(y, \hat{y}) = \frac{1}{n} \sum^n\_{i=1}(y\_i - \hat{y\_i})^2
$$&lt;p>我们通过调整参数$W$和$b$来降低均方误差，或者说是以降低均方误差为目标，学习参数$W$和参数$b$。当均方误差下降的时候，我们认为当前的模型的预测值$Z$与真值$y$越来越接近，也就是说模型正在学习如何让自己的预测值变得更准确。&lt;/p>
&lt;p>在前面的课程中，我们已经学习了这种线性回归模型可以使用最小二乘法求解，最小二乘法在求解数据量较小的问题的时候很有效，但是最小二乘法的时间复杂度很高，一旦数据量变大，效率很低，实际应用中我们会使用梯度下降等基于梯度的优化算法来求解参数$W$和参数$b$。&lt;/p>
&lt;h2 id="梯度下降">梯度下降
&lt;/h2>&lt;p>梯度下降是一种常用的优化算法，通俗来说就是计算出参数的梯度（损失函数对参数的偏导数的导数值），然后将参数减去参数的梯度乘以一个很小的数（下面的公式），来改变参数，然后重新计算损失函数，再次计算梯度，再次进行调整，通过一定次数的迭代，参数就会收敛到最优点附近。&lt;/p>
&lt;p>在我们的这个线性回归问题中，我们的参数是$W$和$b$，使用以下的策略更新参数：&lt;/p>
$$
W := W - \alpha \frac{\partial \mathrm{loss}}{\partial W}
$$$$
b := b - \alpha \frac{\partial \mathrm{loss}}{\partial b}
$$&lt;p>其中，$\alpha$ 是学习率，一般设置为0.1，0.01等。&lt;/p>
&lt;p>接下来我们会求解损失函数对参数的偏导数。&lt;/p>
&lt;p>损失函数MSE记为：&lt;/p>
$$
\mathrm{loss}(y, Z) = \frac{1}{n} \sum^n\_{i = 1} (y\_i - Z\_i)^2
$$&lt;p>其中，$Z \in \mathbb{R}^{n}$是我们的预测值，也就是神经网络输出层的输出值。这里我们有$n$个样本，实际上是将$n$个样本的预测值与他们的真值相减，取平方后加和。&lt;/p>
&lt;p>我们计算损失函数对参数$W$的偏导数，根据链式法则，可以将偏导数拆成两项，分别求解后相乘：&lt;/p>
&lt;p>&lt;strong>这里我们以矩阵的形式写出推导过程，感兴趣的同学可以尝试使用单个样本进行推到，然后推广到矩阵形式&lt;/strong>&lt;/p>
$$\begin{aligned}
\frac{\partial \mathrm{loss}}{\partial W} &amp;= \frac{\partial \mathrm{loss}}{\partial Z} \frac{\partial Z}{\partial W}\\
&amp;= - \frac{2}{n} X^\mathrm{T} (y - Z)\\
&amp;= \frac{2}{n} X^\mathrm{T} (Z - y)
\end{aligned}$$&lt;p>同理，求解损失函数对参数$b$的偏导数:&lt;/p>
$$\begin{aligned}
\frac{\partial \mathrm{loss}}{\partial b} &amp;= \frac{\partial \mathrm{loss}}{\partial Z} \frac{\partial Z}{\partial b}\\
&amp;= - \frac{2}{n} \sum^n\_{i=1}(y\_i - Z\_i)\\
&amp;= \frac{2}{n} \sum^n\_{i=1}(Z\_i - y\_i)
\end{aligned}$$&lt;p>&lt;strong>因为参数$b$对每个样本的损失值都有贡献，所以我们需要将所有样本的偏导数都加和。&lt;/strong>&lt;/p>
&lt;p>其中，$\frac{\partial \mathrm{loss}}{\partial W} \in \mathbb{R}^{m}$，$\frac{\partial \mathrm{loss}}{\partial b} \in \mathbb{R}$，求解得到的梯度的维度与参数一致。&lt;/p>
&lt;p>完成上式两个梯度的计算后，就可以使用梯度下降法对参数进行更新了。&lt;/p>
&lt;p>训练神经网络的基本思路：&lt;/p>
&lt;ol>
&lt;li>首先对参数进行初始化，对参数进行随机初始化（也就是取随机值）&lt;/li>
&lt;li>将样本输入神经网络，计算神经网络预测值 $Z$&lt;/li>
&lt;li>计算损失值MSE&lt;/li>
&lt;li>通过 $Z$ 和 $y$ ，以及 $X$ ，计算参数的梯度&lt;/li>
&lt;li>使用梯度下降更新参数&lt;/li>
&lt;li>循环1-5步，&lt;strong>在反复迭代的过程中可以看到损失值不断减小的现象，如果没有下降说明出了问题&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>接下来我们来实现这个最简单的神经网络。&lt;/p>
&lt;h2 id="1-导入数据">1. 导入数据
&lt;/h2>&lt;p>使用kaggle房价数据，选3列作为特征&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">pandas&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">pd&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">matplotlib.pyplot&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">plt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">%&lt;/span>&lt;span class="n">matplotlib&lt;/span> &lt;span class="n">inline&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 读取数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">pd&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">read_csv&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;data/kaggle_house_price_prediction/kaggle_hourse_price_train.csv&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 使用这3列作为特征&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">features&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;LotArea&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;BsmtUnfSF&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;GarageArea&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">target&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;SalePrice&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">features&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="2-数据预处理">2. 数据预处理
&lt;/h2>&lt;p>40%做测试集，60%做训练集&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">sklearn.model_selection&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">train_test_split&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">trainX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">testX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">trainY&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">testY&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">train_test_split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">features&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">test_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">random_state&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>训练集876个样本，3个特征，测试集584个样本，3个特征&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">trainX&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">shape&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">trainY&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">shape&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">testX&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">shape&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">testY&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">shape&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="3-参数初始化">3. 参数初始化
&lt;/h2>&lt;p>这里，我们要初始化参数$W$和$b$，其中$W \in \mathbb{R}^m$，$b \in \mathbb{R}$，初始化的策略是将$W$初始化成一个随机数矩阵，参数$b$为0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">initialize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> 参数初始化，将W初始化成一个随机向量，b是一个长度为1的向量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> Parameters
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>决策树为什么要引入随机数</title><link>https://davidham3.github.io/blog/p/%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E9%9A%8F%E6%9C%BA%E6%95%B0/</link><pubDate>Sat, 01 Sep 2018 14:40:52 +0000</pubDate><guid>https://davidham3.github.io/blog/p/%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid><description>&lt;p>最近在使用scikit-learn的决策树的时候发现每次生成的树都不一样。发现决策树里面的有个random_state的参数，但是没想明白为什么会有这么个参数。&lt;/p>
&lt;p>最近给本科生的机器学习课程做助教，需要给他们出作业题，想做一个决策树相关的练习，生成了一批随机数据，然后画出决策树的decision boundary，结果发现，这个边界每次都不一样，然后就没想明白，决策树每次生成的不应该是一样的树吗，为什么边界会变化。&lt;/p>
&lt;p>查了一下之后，发现如果决策树对连续性变量进行分类的时候，需要取一个中间值，这个中间值一般要加入随机因素，这样生成的树就不一样了。&lt;/p></description></item><item><title>Gaussian Naive Bayes</title><link>https://davidham3.github.io/blog/p/gaussian-naive-bayes/</link><pubDate>Thu, 14 Jun 2018 19:33:30 +0000</pubDate><guid>https://davidham3.github.io/blog/p/gaussian-naive-bayes/</guid><description>&lt;p>假设连续型随机变量服从高斯分布的朴素贝叶斯。发现自己实现的版本比sklearn的精度低了20%左右……研究了一下差在了哪里。&lt;/p>
&lt;h1 id="朴素贝叶斯">朴素贝叶斯
&lt;/h1>&lt;p>朴素贝叶斯是基于贝叶斯定理与特征条件独立假设的分类器。&lt;/p>
&lt;h2 id="原理">原理
&lt;/h2>&lt;p>朴素贝叶斯通过给定训练集&lt;/p>
$$T = \lbrace (x\_1, y\_1), (x\_2, y\_2), ···, (x\_N, y\_N)\rbrace $$&lt;p>训练学习到联合概率分布$P(X, Y)$，通过先验概率分布&lt;/p>
$$P(Y = c\_k), k = 1,2,...,K$$&lt;p>和条件概率分布&lt;/p>
$$P(X = x \mid Y = c\_k) = P(X^{(1)} = x^{(1)}, ···, X^{(n)} = x^{(n)} \mid Y = c\_k), k=1,2,...,K$$&lt;p>学习到联合概率分布$P(X, Y)$&lt;/p>
&lt;p>由特征相互独立假设，可得&lt;/p>
$$P(X = x \mid Y = c\_k) = \prod^n\_{j=1}P(X^{(j)}=x^{(j)} \mid Y = c\_k)$$&lt;p>分类时，对给定的输入$x$，模型计算$P(Y = c_k \mid X = x)$，将后验概率最大的类作为$x$的类输出，后验概率计算如下：&lt;/p>
$$
\begin{aligned}
P(Y = c\_k \mid X = x) &amp;= \frac{P(X = x \mid Y = c\_k)P(Y = c\_k)}{\sum\_kP(X = x \mid Y = c\_k)P(Y = c\_k)} \\
&amp; = \frac{P(Y = c\_k) \prod\_j P(X^{(j)} = x^{(j)} \mid Y = c\_k)}{\sum\_k P(Y = c\_k) \prod\_j P(X^{(j)} = x^{(j)} \mid Y = c\_k)}
\end{aligned}
$$&lt;p>由于分母对任意的$c_k$都相同，故朴素贝叶斯分类器可以表示为：&lt;/p>
$$
y = \mathop{\arg\max}\_{c\_k} P(Y = c\_k) \prod\_j P(X^{(j)} = x^{(j)} \mid Y = c\_k)
$$&lt;h2 id="参数估计">参数估计
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>如果特征是离散型随机变量，可以使用频率用来估计概率。&lt;/p>
$$P(Y = c\_k) = \frac{\sum^N\_{i=1}I(y\_i = c\_k)}{N}, k=1,2,...,K$$&lt;p>设第$j$个特征的取值的集合为${a_{j1}, a_{j2}, &amp;hellip;, a_{js_j}}$，则&lt;/p>
$$
\begin{gathered}P(X^{(j)} = a\_{jl} \mid Y = c\_k) = \frac{\sum^N\_{i=1}I(x^{(j)}\_i = a\_{jl}, y\_i = c\_k)}{\sum^N\_{i=1}I(y\_i = c\_k)}\\
j=1,2,...,n; \ l=1,2,...,S\_j; \ k=1,2,...,K
\end{gathered}
$$&lt;/li>
&lt;li>
&lt;p>如果特征是连续型随机变量，可以假设正态分布来估计条件概率。&lt;/p>
$$P(X^{(j)} = a\_{jl} \mid Y = c\_k) = \frac{1}{\sqrt{2 \pi \sigma^2\_{c\_k,j}}}\exp{(- \frac{(a\_{jl} - \mu\_{c\_k,j})^2}{2 \sigma^2\_{c\_k,j}})}$$&lt;p>这里$\mu_{c_k,j}$和$\sigma^2_{c_k,j}$分别为$Y = c_k$时，第$j$个特征的均值和方差。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="代码">代码
&lt;/h2>&lt;p>因为二值分类和$n$值分类是一样的，故以下代码只实现了$n$值分类的朴素贝叶斯分类器。
仓库:&lt;a class="link" href="https://github.com/Davidham3/naive_bayes" target="_blank" rel="noopener"
>https://github.com/Davidham3/naive_bayes&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># -*- coding:utf-8 -*-&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">collections&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">defaultdict&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">readDataSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">filename&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">frequency&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">training_set_ratio&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shuffle&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">True&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s1">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> read the dataset file, and shuffle, remove all punctuations
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s1"> Parameters
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>训练神经网络时归一化的目的</title><link>https://davidham3.github.io/blog/p/%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%97%B6%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E7%9B%AE%E7%9A%84/</link><pubDate>Wed, 21 Feb 2018 13:39:35 +0000</pubDate><guid>https://davidham3.github.io/blog/p/%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%97%B6%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E7%9B%AE%E7%9A%84/</guid><description>&lt;p>在训练神经网络的时候，normalization是必不可少的，原因是如果不进行normalization，在更新参数的时候会出现zig zag的现象。&lt;/p>
&lt;p>在训练神经网络的时候，归一化是必不可少的。之前一直不理解为什么非要归一化，直到看了cs231n这门课才知道归一化的目的。
事实上这个问题主要是针对激活函数来说，如果不归一化的话，那么激活函数在反向传播的时候就会出问题。
&lt;img src="https://davidham3.github.io/blog/images/%e8%ae%ad%e7%bb%83%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e6%97%b6%e5%bd%92%e4%b8%80%e5%8c%96%e7%9a%84%e7%9b%ae%e7%9a%84/1.png"
loading="lazy"
alt="“图1 图片来源于cs231n”"
>
图1 左侧是原始数据，中间是中心化后的，右侧是归一化后的 图片来源于cs231n
事实上归一化分为两个步骤，第一步是将数据变为以0为中心，第二部是缩小数据的范围。所以归一化的公式为：
&lt;/p>
$$\frac{X-\bar{X}}{std(X)}$$&lt;p>
其中，X为原始样本，$\bar{X}$为样本均值，$std(X)$为样本标准差。
在这里，真正影响反向传播的是第一步，zero-centered。如果没有将数据以0为中心中心化的话，就会影响反向传播的效果。
以逻辑回归(Logistic Regression)为例，逻辑回归的模型可写为
&lt;/p>
$$\hat{y} = sigmoid(W \cdot X+b)$$&lt;p>
其中$W$和$b$是参数，X是样本，$sigmoid$表示sigmoid激活函数，设损失函数为
&lt;/p>
$$L = Loss(y, \hat{y})$$&lt;p>
其中，$y$为样本的标签或标注值。在反向传播的时候，需要对$W$和$b$求偏导数，即求损失函数在当前样本点的梯度，这里我们设$Z = W \cdot X + b$，则
&lt;/p>
$$\frac{\partial{L}}{\partial{W}} = \frac{\partial{L}}{\partial{\hat{y}}}\frac{\partial{\hat{y}}}{\partial{Z}}\frac{\partial{Z}}{\partial{W}} = \frac{\partial{L}}{\partial{\hat{y}}}\frac{\partial{\hat{y}}}{\partial{Z}}X^T$$&lt;p>
同理可以求出$b$的偏导数。
在这里就可以看出问题，假设我们的输入是图像那样的样本，像素值都是大于0的，那这里$\frac{\partial{L}}{\partial{W}}$就会大于0。
使用梯度下降的更新规则来更新参数时
&lt;/p>
$$W := W - \alpha \frac{\partial{L}}{\partial{W}}$$&lt;p>
W就会一直减小，这显然是有问题的。
&lt;img src="https://davidham3.github.io/blog/images/%e8%ae%ad%e7%bb%83%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e6%97%b6%e5%bd%92%e4%b8%80%e5%8c%96%e7%9a%84%e7%9b%ae%e7%9a%84/2.png"
loading="lazy"
alt="“图2 图片来源于cs231n”"
>
图2 右图展示了只有两个方向允许更新梯度后实际的参数更新路线(红线) 图片来源于cs231n
如图2所示，可以发现如果我们的输入变成了要么都是大于0，要么都是小于0的数，那么允许梯度更新的两个方向在二维空间中就只能落在第一和第三象限中，扩展到高维空间中也是相对的两个卦限。这样在更新的过程中就会产生这种红线所示的路径zig zag path。以上是不进行中心化的后果。
而不进行特征缩放的后果则是，如果每个特征的量级不同，假设一个特征是数值范围在$[-10, 10]$，另一个特征在$[-10^9, 10^9]$，那么在计算梯度后，使用梯度下降更新时，也会造成上面所述的zig zag现象。&lt;/p></description></item></channel></rss>