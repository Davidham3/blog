<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="最近在做轨迹数据分析相关的项目，需要计算轨迹之间的距离。一开始用的是 traj-dist 这个 Python 包，它提供了多种轨迹距离算法的实现，速度很快，因为是通过Cython加速的。但是这个包有点太老了，安装起来很麻烦。\n于是我想着能不能用 Rust 重写一遍，一是为了适配更新的python版本，二是为了尝试“用rust重写一切”。\n实现完了之后测试了一下性能，吓了一跳：相比 traj-dist 的 Python 实现，性能提升了 389 倍，相比 Cython 实现也提升了 10 倍。本文我会分享一下这个项目的一些经验和踩过的坑。\n"><title>性能提升10倍！我用Rust重写Python轨迹距离计算库的实践分享</title><link rel=canonical href=https://davidham3.github.io/blog/p/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%8710%E5%80%8D%E6%88%91%E7%94%A8rust%E9%87%8D%E5%86%99python%E8%BD%A8%E8%BF%B9%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97%E5%BA%93%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB/><link rel=stylesheet href=/blog/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css><meta property='og:title' content="性能提升10倍！我用Rust重写Python轨迹距离计算库的实践分享"><meta property='og:description' content="最近在做轨迹数据分析相关的项目，需要计算轨迹之间的距离。一开始用的是 traj-dist 这个 Python 包，它提供了多种轨迹距离算法的实现，速度很快，因为是通过Cython加速的。但是这个包有点太老了，安装起来很麻烦。\n于是我想着能不能用 Rust 重写一遍，一是为了适配更新的python版本，二是为了尝试“用rust重写一切”。\n实现完了之后测试了一下性能，吓了一跳：相比 traj-dist 的 Python 实现，性能提升了 389 倍，相比 Cython 实现也提升了 10 倍。本文我会分享一下这个项目的一些经验和踩过的坑。\n"><meta property='og:url' content='https://davidham3.github.io/blog/p/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%8710%E5%80%8D%E6%88%91%E7%94%A8rust%E9%87%8D%E5%86%99python%E8%BD%A8%E8%BF%B9%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97%E5%BA%93%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB/'><meta property='og:site_name' content='Davidham的博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='trajectory'><meta property='article:tag' content='rust'><meta property='article:published_time' content='2026-02-08T23:18:49+00:00'><meta property='article:modified_time' content='2026-02-08T23:18:49+00:00'><meta name=twitter:title content="性能提升10倍！我用Rust重写Python轨迹距离计算库的实践分享"><meta name=twitter:description content="最近在做轨迹数据分析相关的项目，需要计算轨迹之间的距离。一开始用的是 traj-dist 这个 Python 包，它提供了多种轨迹距离算法的实现，速度很快，因为是通过Cython加速的。但是这个包有点太老了，安装起来很麻烦。\n于是我想着能不能用 Rust 重写一遍，一是为了适配更新的python版本，二是为了尝试“用rust重写一切”。\n实现完了之后测试了一下性能，吓了一跳：相比 traj-dist 的 Python 实现，性能提升了 389 倍，相比 Cython 实现也提升了 10 倍。本文我会分享一下这个项目的一些经验和踩过的坑。\n"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/blog/><img src=/blog/img/avatar_hu_a95981f1fc190aef.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🚀</span></figure><div class=site-meta><h1 class=site-name><a href=/blog>Davidham的博客</a></h1><h2 class=site-description>随便写写</h2></div></header><ol class=menu-social><li><a href=https://github.com/Davidham3 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/blog/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/blog/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/blog/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/blog/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#一为什么要重写>一、为什么要重写</a></li><li><a href=#二重写思路>二、重写思路</a></li><li><a href=#三性能测试结果>三、性能测试结果</a></li><li><a href=#四架构设计>四、架构设计</a><ol><li><a href=#41-rust接口设计>4.1 rust接口设计</a></li><li><a href=#42-动态规划算法优化>4.2 动态规划算法优化</a><ol><li><a href=#421-动态规划算法的类型抽象>4.2.1 动态规划算法的类型抽象</a></li><li><a href=#422-动态规划算法内存优化>4.2.2 动态规划算法内存优化</a></li></ol></li><li><a href=#43-双接口支持>4.3 双接口支持</a></li></ol></li><li><a href=#五踩过的坑>五、踩过的坑</a><ol><li><a href=#51-球面距离的精度问题>5.1 球面距离的精度问题</a></li><li><a href=#52-erp-算法的实现问题>5.2 ERP 算法的实现问题</a></li></ol></li><li><a href=#六精度保证>六、精度保证</a></li><li><a href=#七总结>七、总结</a></li><li><a href=#附录>附录</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/blog/p/%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%8710%E5%80%8D%E6%88%91%E7%94%A8rust%E9%87%8D%E5%86%99python%E8%BD%A8%E8%BF%B9%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97%E5%BA%93%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB/>性能提升10倍！我用Rust重写Python轨迹距离计算库的实践分享</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 08, 2026</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 10 分钟</time></div></footer></div></header><section class=article-content><p>最近在做轨迹数据分析相关的项目，需要计算轨迹之间的距离。一开始用的是 <code>traj-dist</code> 这个 Python 包，它提供了多种轨迹距离算法的实现，速度很快，因为是通过Cython加速的。但是这个包有点太老了，安装起来很麻烦。</p><p>于是我想着能不能用 Rust 重写一遍，一是为了适配更新的python版本，二是为了尝试“用rust重写一切”。</p><p>实现完了之后测试了一下性能，吓了一跳：相比 <code>traj-dist</code> 的 Python 实现，性能提升了 389 倍，相比 Cython 实现也提升了 10 倍。本文我会分享一下这个项目的一些经验和踩过的坑。</p><h2 id=一为什么要重写>一、为什么要重写</h2><p><code>traj-dist</code> 是一个挺不错的包，提供了多种主流的轨迹距离算法：</p><ul><li>SSPD（对称段路径距离）</li><li>DTW（动态时间规整）</li><li>Hausdorff 距离</li><li>LCSS（最长公共子序列）</li><li>EDR（实数序列编辑距离）</li><li>ERP（带实数惩罚的编辑距离）</li><li>Discret Fréchet 距离</li><li>还有很多，我还没有重写</li></ul><p>支持欧几里得距离和球面距离（Haversine），API 设计得很简单。</p><p>但是，核心痛点是这个包的安装比较麻烦，我尝试过在python3.12上安装，但是发现它的依赖太老。而且每次安装都需要编译Cython代码。为此我希望有一个安装简单，而且依赖比较少的包出现。</p><h2 id=二重写思路>二、重写思路</h2><p>我先说一下我的重写思路：</p><ol><li>确定需要重写的算法：首先我在<code>traj-dist</code>里面挑选了一些简单的算法：<ul><li>LCSS、DTW、discrete frechet、EDR、ERP，这些都是动态规划算法</li><li>hausdorff，sspd，这两个算法是非动态规划的算法，实现起来相对简单</li><li>其他算法的实现稍微复杂了一些，就留在后面的版本了</li></ul></li><li>以<code>traj-dist</code>为ground truth：我发现作者在代码仓库里面提供了一个很小的轨迹数据集，并且作者自己在上面进行了性能测试，那我们可以利用这个数据集，使用<code>traj-dist</code>在上面完成上面7个算法的计算，记录结果与耗时。</li><li>使用rust重写上述7个算法，rust里面使用trait表示经纬度点和轨迹，为其他人使用这个包提供扩展性。同时为rust编写单元测试用例，保证其API都是可用的。</li><li>为rust的算法和trait定义python相关的类型和算法，暴露给python。同时为python部分编写测试用例，一方面保证API可用，另一方面与上面的ground truth做对比，确保每个算法的计算结果与ground truth的结果偏差值在1e-8以内。</li><li>由于ground truth里面带了<code>traj-dist</code>的性能，因此<code>traj-dist-rs</code>也可以很轻松地做出性能对比，得到rust相对于python和cython的性能提升比例。</li></ol><h2 id=三性能测试结果>三、性能测试结果</h2><p>性能测试这里，首先随机选1000个轨迹pair，每个样本预热10次，正式测量50次，记录这50次的明细时间，并统计中位数、Coefficient of Variation等值。</p><p>因此会用<code>traj-dist</code>的python版本、cython版本，<code>traj-dist-rs</code>的python版本运行相同的测试用例，记录均值、标准差、CV值。</p><p>下面是具体的提升效果：</p><p><strong>EUCLIDEAN 距离</strong></p><ul><li><strong>Rust vs Cython</strong>: 平均提升 9.99x (范围: 6.06x - 16.13x)</li><li>Rust vs Python: 平均提升 389.07x (范围: 187.20x - 594.74x)</li><li><strong>最佳性能提升算法</strong>: sspd (16.13x)</li></ul><p><strong>SPHERICAL 距离</strong></p><ul><li><strong>Rust vs Cython</strong>: 平均提升 2.66x (范围: 1.62x - 5.24x)</li><li>Rust vs Python: 平均提升 75.67x (范围: 41.13x - 167.14x)</li><li><strong>最佳性能提升算法</strong>: erp (5.24x)</li></ul><p>这个结果比我预期的要好很多。相比 Python 实现提升 389 倍，这主要是因为 Rust 没有解释器开销，像动态规划算法这种需要双重for循环的算法，python一定是非常慢的，而且rust的编译器能做很多优化。相比 Cython 实现提升 10 倍，这部分主要是数据拷贝带来的，rust的实现中使用了numpy+零拷贝的方案，避免了数据复制，论计算性能来说，rust和cython生成的c代码，本质上应该不会有太大区别。</p><p>至于欧氏距离上的性能提升远大于球面距离的提升，这是因为欧氏距离的计算太简单，&ldquo;语言效率"成为瓶颈，Rust 优势明显；球面距离的计算太复杂，&ldquo;数学计算"成为瓶颈，Rust 优势被稀释。</p><h2 id=四架构设计>四、架构设计</h2><p>接下来说一下架构的设计，核心有几个内容吧：</p><ol><li>rust接口设计</li><li>动态规划算法优化</li><li>rust与python的双接口设计</li></ol><h3 id=41-rust接口设计>4.1 rust接口设计</h3><p>rust设计了几个关键的Trait：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>AsCoord</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Get the x-coordinate (longitude or easting)
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Returns the x-coordinate value of the point.
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>x</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>f64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Get the y-coordinate (latitude or northing)
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Returns the y-coordinate value of the point.
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>y</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>f64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个AsCoord用来表示一个经纬度点，因为肯定要计算经纬度点之间的距离，那么用这样一个trait抽象，不论用户是用<code>&[f64]</code>还是<code>vec</code>，都可以轻松支持，并且保证很好的性能。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>CoordSequence</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// The type of coordinate in this sequence
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Coord</span>: <span class=nc>AsCoord</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Get the number of coordinates in the sequence
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Returns the total number of coordinate points in the sequence.
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>len</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Check if the sequence is empty
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Returns `true` if the sequence contains no coordinates, `false` otherwise.
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// This is implemented as `self.len() == 0` by default.
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>is_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Get the i-th coordinate in the sequence
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Returns a copy of the coordinate at the specified index.
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// # Panics
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>///
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// This method may panic if the index is out of bounds.
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>get</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>i</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Coord</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个trait表示轨迹，也就是经纬度序列。因此只要用户将自己的数据类型实现这个trait的接口，就可以调用<code>traj-dist-rs</code>里面的距离计算函数了。</p><h3 id=42-动态规划算法优化>4.2 动态规划算法优化</h3><h4 id=421-动态规划算法的类型抽象>4.2.1 动态规划算法的类型抽象</h4><p>对于动态规划算法来说，一般只需要计算任意两个点之间的距离。考虑到用户需要使用的距离计算方法<code>traj-dist-rs</code>不支持，比如导航距离。因此需要给用户提供一个类似scikit-learn的方案：用户可用预先计算好任意两点之间的距离，然后传入这个“预计算距离矩阵”。</p><p>因此对于动态规划类的算法，<code>traj-dist-rs</code>提供两种接口形式：</p><ol><li>用户可用传入2条原始的经纬度序列。</li><li>用户提供一个预计算距离矩阵。</li></ol><p>针对这两种类型，我定义了一个叫<code>DistanceCalculator</code>的trait。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>DistanceCalculator</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Calculate the distance between corresponding elements in two sequences
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>dis_between</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>seq_a_idx</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>seq_b_idx</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>f64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Calculate the distance between a point in a sequence and an external &#34;anchor&#34; point
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>compute_dis_for_extra_point</span><span class=o>&lt;</span><span class=n>C</span>: <span class=nc>AsCoord</span><span class=o>&gt;</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>seq_id</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>point_idx</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>anchor</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=n>C</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>f64</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Length of sequence 1
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>len_seq1</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Length of sequence 2
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>len_seq2</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>动态规划算法完全可以通过这个trait的泛型，取出任意两点之间的距离，完成动态规划算法的计算。</p><p>当然，<code>traj-dist-rs</code>里面提供了两个具体的类型实现了这个trait。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>TrajectoryCalculator</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>U</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>T</span>: <span class=nc>CoordSequence</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>U</span>: <span class=nc>CoordSequence</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>traj1</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>T</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>traj2</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>U</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>metric</span>: <span class=nc>DistanceType</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>PrecomputedDistanceCalculator</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>distance_matrix</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>seq1_extra_dists</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>seq2_extra_dists</span>: <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ol><li><code>TrajectoryCalculator</code>：直接访问轨迹数据，按需计算距离</li><li><code>PrecomputedDistanceCalculator</code>：使用预计算的距离矩阵</li></ol><p>这样的好处是算法逻辑和距离计算逻辑解耦，如果将来要支持其他距离计算方式，只需要实现新的 Calculator 就可以了。比如用户需要实时调用接口获取两点之间的导航距离，那么用户自己实现这个trait就可以使用动态规划算法了。</p><p>下面的代码是使用<code>traj-dist-rs</code>提供的<code>TrajectoryCalculator</code>调用动态规划算法的示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>traj_dist_rs</span>::<span class=n>distance</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>base</span>::<span class=n>TrajectoryCalculator</span><span class=p>,</span><span class=w> </span><span class=n>distance_type</span>::<span class=n>DistanceType</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>traj1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[[</span><span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=mf>0.0</span><span class=p>],</span><span class=w> </span><span class=p>[</span><span class=mf>1.0</span><span class=p>,</span><span class=w> </span><span class=mf>1.0</span><span class=p>]];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>traj2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[[</span><span class=mf>0.0</span><span class=p>,</span><span class=w> </span><span class=mf>1.0</span><span class=p>],</span><span class=w> </span><span class=p>[</span><span class=mf>1.0</span><span class=p>,</span><span class=w> </span><span class=mf>0.0</span><span class=p>]];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>calculator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>TrajectoryCalculator</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=n>traj1</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>traj2</span><span class=p>,</span><span class=w> </span><span class=n>DistanceType</span>::<span class=n>Euclidean</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>dist</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>distance</span>::<span class=n>dtw</span>::<span class=n>dtw</span><span class=p>(</span><span class=o>&amp;</span><span class=n>calculator</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=422-动态规划算法内存优化>4.2.2 动态规划算法内存优化</h4><p><code>traj-dist-rs</code>针对动态规划算法还做了一个内存上的优化：对于大部分动态规划算法，当我们不需要回溯动态规划算法的路径的时候，其空间复杂度可以缩减到<code>O(MN) -> O(min{M, N})</code>，这里的M和N是2条序列的长度。<code>traj-dist-rs</code>会默认使用这种算法记录动态规划算法的中间值，实现内存使用的下降。</p><h3 id=43-双接口支持>4.3 双接口支持</h3><p>这个项目同时提供了 Rust API 和 Python 绑定。因为据我了解计算轨迹距离，大家基本都是python实现，而且学术界用得更多，因为轨迹表示学习之后的度量方式，很多论文会使用更传统的metrics，比如DTW，frechet等。</p><p>因此如果要用python做的话，cython这个加速方案有点老了，而且需要学习cython代码；pybind11与c++的方案也可以，但是不如pyo3+rust的方案。</p><p>如果是这样，我还不希望这个包只服务python用户，应该也能服务rust用户。这样就要求rust的代码应该更简单、抽象、内聚，在此基础上添加python的binding。</p><p>Python 绑定通过 PyO3 实现，API 设计尽量保持和 traj-dist 一致：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>traj_dist_rs</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>traj1</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>],</span> <span class=p>[</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=n>traj2</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>([[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>],</span> <span class=p>[</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用方式几乎和 traj-dist 一样</span>
</span></span><span class=line><span class=cl><span class=n>dist</span> <span class=o>=</span> <span class=n>traj_dist_rs</span><span class=o>.</span><span class=n>dtw</span><span class=p>(</span><span class=n>traj1</span><span class=p>,</span> <span class=n>traj2</span><span class=p>,</span> <span class=s2>&#34;euclidean&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>dist</span> <span class=o>=</span> <span class=n>traj_dist_rs</span><span class=o>.</span><span class=n>lcss</span><span class=p>(</span><span class=n>traj1</span><span class=p>,</span> <span class=n>traj2</span><span class=p>,</span> <span class=s2>&#34;euclidean&#34;</span><span class=p>,</span> <span class=n>eps</span><span class=o>=</span><span class=mf>0.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ERP 有两个版本</span>
</span></span><span class=line><span class=cl><span class=n>dist_standard</span> <span class=o>=</span> <span class=n>traj_dist_rs</span><span class=o>.</span><span class=n>erp_standard</span><span class=p>(</span><span class=n>traj1</span><span class=p>,</span> <span class=n>traj2</span><span class=p>,</span> <span class=s2>&#34;euclidean&#34;</span><span class=p>,</span> <span class=n>g</span><span class=o>=</span><span class=p>[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>dist_compat</span> <span class=o>=</span> <span class=n>traj_dist_rs</span><span class=o>.</span><span class=n>erp_compat_traj_dist</span><span class=p>(</span><span class=n>traj1</span><span class=p>,</span> <span class=n>traj2</span><span class=p>,</span> <span class=s2>&#34;euclidean&#34;</span><span class=p>,</span> <span class=n>g</span><span class=o>=</span><span class=p>[</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><p>考虑到大部分数据都是在python中读取的，那么如何让rust通过零拷贝的方式读取是提升性能的一个关键。因为传统方式里面，当 Python 调用 C/C++/Cython 模块时，往往需要先把这箱货物“卸下”（从Python内存），再“搬运”并“重新打包”（复制到C/C++/Cython能理解的内存结构中）。这个过程是有开销的。</p><p>我这里利用了numpy的c-contiguous特性，当numpy.ndarray的数据在内存中是连续存储的时候，可以不需要“搬运”和“打包”操作，直接在原地打开货物。也就是说：rust可以直接读取python中的numpy.ndarray的数据，而不是复制一份。这里rust拿到的是一个<code>&[f64]</code>的切片。接下来只要把这个切片实现上面介绍的<code>CoordSequence</code>接口，就可以适配各个算法了。rust的零成本抽象可以直接让各个算法操作这块内存中的数据，以此实现性能提升，同时也避免了数据的拷贝，这也是rust性能超越cython的核心原因。</p><h2 id=五踩过的坑>五、踩过的坑</h2><p>做这个项目的过程中，也发现了一些问题。</p><h3 id=51-球面距离的精度问题>5.1 球面距离的精度问题</h3><p>一开始测试的时候，我发现球面距离计算的结果和 <code>traj-dist</code> 的结果对不上。排查了很久，最后发现问题出在 <code>traj-dist</code> 的 Cython 实现上。</p><p>traj-dist 的 Cython 代码中，球面距离计算使用的是 <code>float</code>（32 位浮点数），而且 PI 值是硬编码的截断值：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cython data-lang=cython><span class=line><span class=cl><span class=k>cdef</span> <span class=kt>double</span> <span class=nf>pi</span> <span class=o>=</span> <span class=mf>3.14159265</span>
</span></span></code></pre></td></tr></table></div></div><p>这个精度显然不够。为了和 <code>traj-dist</code> 的结果对比，我fork并修改了<code>traj-dist</code>的源码，把 <code>float</code> 改成 <code>double</code>，使用 <code>M_PI</code> 常量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cython data-lang=cython><span class=line><span class=cl><span class=k>cdef</span> <span class=kt>double</span> <span class=nf>pi</span> <span class=o>=</span> <span class=n>M_PI</span>
</span></span></code></pre></td></tr></table></div></div><p>修复后，Rust 实现和 traj-dist 的结果就对上了。</p><h3 id=52-erp-算法的实现问题>5.2 ERP 算法的实现问题</h3><p>在测试过程中，我发现 traj-dist 的 ERP 算法实现有问题。</p><p>ERP算法是典型的动态规划算法，在初始化动态规划矩阵的边界值的时候，也就是<code>C[0,:]</code>和<code>C[:,0]</code>，<code>traj-dist</code>使用了错误的方法，给每个值都初始化成了相同的值，这里的正确实现应该是不同的值。</p><p>这里我纠结了半天，考虑到这个包已经被很多人用了，直接修改 API 会破坏兼容性。</p><p>于是我想了个折中的方案：提供两个版本</p><ul><li><code>erp_standard</code>：按照正确的算法实现</li><li><code>erp_compat_traj_dist</code>：按照 <code>traj-dist</code> 的问题版本实现，保持兼容性。</li></ul><p>这样，新用户可以用正确的实现，老用户如果需要和原来保持一致，也可以用兼容版本。</p><h2 id=六精度保证>六、精度保证</h2><p><code>traj-dist-rs</code>的实现，以<code>traj-dist</code>为基准，因此需要两者跑出来的结果尽可能一致。</p><p>这里我做了两件事：</p><ol><li>首先修改<code>traj-dist</code>的球面距离计算代码，将所有的float部分替换为double，并且修改PI的值为M_PI，以获得更高的精度。</li><li>因为<code>traj-dist</code>的erp算法实现有误，为了保证结果的一致性，我这里测量的是<code>traj-dist-rs</code>的<code>erp_compat_traj_dist</code>与<code>traj-dist</code>的erp算法之间的误差。</li></ol><p>测算下来误差远远小于我期望的1e-8的阈值，说明<code>traj-dist-rs</code>实现了算法的正确实现。</p><h2 id=七总结>七、总结</h2><p><code>traj-dist-rs</code>的实现我觉得有几个亮点：</p><ol><li>使用rust重写</li><li>与python的绑定中考虑了零拷贝的问题</li><li>rust层面做了比较好的抽象，不论是<code>CoordSequence</code>还是<code>DistanceCalculator</code>。</li><li>所有动态规划算法提供了节省内存的实现。</li><li>确实实现了性能的显著提升。</li></ol><p>如果你也在做轨迹数据分析，或者对 Rust 性能优化感兴趣，欢迎试试 <code>traj-dist-rs</code>。项目地址在：<a class=link href=https://github.com/Davidham3/traj-dist-rs target=_blank rel=noopener>traj-dist-rs</a>。目前alpha版本已经发布在crates.io和pypi，同时也支持context7。</p><p>有任何问题或建议，欢迎交流！</p><h2 id=附录>附录</h2><ol><li>修复球面距离精度的：<a class=link href=https://github.com/Davidham3/traj-dist target=_blank rel=noopener>traj-dist</a>。</li><li>完整的性能测试记录：<a class=link href=https://github.com/Davidham3/traj-dist-rs/blob/v0.1.0-alpha.3/docs/performance.md target=_blank rel=noopener>performance.md</a>。</li></ol></section><footer class=article-footer><section class=article-tags><a href=/blog/tags/trajectory/>Trajectory</a>
<a href=/blog/tags/rust/>Rust</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under Apache License 2.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=document.querySelector(".main-article");renderMathInElement(e,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/blog/p/%E4%BB%8E130%E5%80%8D%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E7%9C%8Bpython%E7%9A%84%E6%89%B9%E9%87%8F%E8%AE%A1%E7%AE%97%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%8C%96%E7%AD%96%E7%95%A5traj-dist-rs%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0/><div class=article-details><h2 class=article-title>从130倍性能提升看Python的批量计算和并行化策略：traj-dist-rs的并行策略实现</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2026 Davidham的博客</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/blog/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>